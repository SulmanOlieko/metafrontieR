% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sfametafrontier.R
\name{sfametafrontier}
\alias{sfametafrontier}
\alias{print.sfametafrontier}
\title{Stochastic metafrontier estimation}
\usage{
sfametafrontier(
  formula,
  muhet,
  uhet,
  vhet,
  thet,
  logDepVar = TRUE,
  data,
  subset,
  group = NULL,
  S = 1L,
  udist = "hnormal",
  scaling = FALSE,
  groupType = "sfacross",
  metaMethod = "lp",
  sfaApproach = "huang",
  selectionF = NULL,
  lcmClasses = 2L,
  whichStart = 2L,
  initAlg = "nm",
  initIter = 100L,
  lType = "ghermite",
  Nsub = 100L,
  uBound = Inf,
  intol = 1e-06,
  method = "bfgs",
  hessianType = 1L,
  simType = "halton",
  Nsim = 100L,
  prime = 2L,
  burn = 10L,
  antithetics = FALSE,
  seed = 12345L,
  itermax = 2000L,
  printInfo = FALSE,
  tol = 1e-12,
  gradtol = 1e-06,
  stepmax = 0.1,
  qac = "marquardt",
  ...
)

\method{print}{sfametafrontier}(x, ...)
}
\arguments{
\item{formula}{A symbolic description of the frontier model.}

\item{muhet}{A one-part formula for heterogeneity in the mean of the
pre-truncated distribution (only for \code{groupType = "sfacross"}). This
formula is used to capture structural differences in the modeled efficiency
mean.}

\item{uhet}{A one-part formula for heteroscedasticity in the one-sided error
term. To accommodate heteroscedasticity in the variance parameters, the
variances are modeled as: \eqn{\sigma^2_{u} = \exp(\delta'Z_u)}, where
\eqn{Z_u} are the inefficiency drivers and \eqn{\delta} are the coefficients.}

\item{vhet}{A one-part formula for heteroscedasticity in the two-sided error
term. Modeled as \eqn{\sigma^2_{v} = \exp(\phi'Z_v)}, where \eqn{Z_v} are
the heteroscedasticity variables and \eqn{\phi} the coefficients.}

\item{thet}{A one-part formula for technological heterogeneity in LCM class
construction (only for \code{groupType = "sfalcmcross"}). The variables
specified are used in the logit formulation of the finite mixture model to
compute the prior class membership probabilities.}

\item{logDepVar}{Logical. Whether the dependent variable is logged. Default
\code{TRUE}.}

\item{data}{The data frame.}

\item{subset}{An optional subset vector.}

\item{group}{Character string. Name of the column in \code{data} that
identifies the technology groups. Must have at least 2 unique values.}

\item{S}{\code{1} (default) for production/profit frontier; \code{-1} for
cost frontier.}

\item{udist}{Character string. Distribution for the one-sided error term.
For \code{groupType = "sfacross"}: all 10 distributions supported (see
\code{\link[sfaR]{sfacross}}). For \code{groupType = "sfaselectioncross"} or
\code{"sfalcmcross"}: only \code{'hnormal'}.}

\item{scaling}{Logical. Scaling property model for \code{groupType =
  "sfacross"} when \code{udist = 'tnormal'}. If \code{TRUE}, the scaling
property is used to model the one-sided error conditional on the inefficiency drivers
\eqn{Z_u} (e.g. \eqn{u = h(Z_u, \delta)u^*} where \eqn{u^*} is a homoscedastic
random variable). Default \code{FALSE}.}

\item{groupType}{Character string. Type of model used for each group's
frontier. \code{"sfacross"} (default) estimates a standard cross-sectional
SFA, \code{"sfaselectioncross"} estimates a sample selection SFA adjusting
for bias via a generalized Heckman approach, or \code{"sfalcmcross"} estimates
a latent class SFA estimating a pooled mixture model.}

\item{metaMethod}{Character string. Method for estimating the metafrontier.
\itemize{
\item \code{"lp"} (default): Deterministic envelope (column-wise maximum
of group frontier values evaluated at all observations).
\item \code{"qp"}: Constrained OLS of the envelope on \eqn{X}.
\item \code{"sfa"}: Second-stage pooled SFA. The approach depends on
\code{sfaApproach}.
}}

\item{sfaApproach}{Character string. Only relevant when \code{metaMethod =
  "sfa"}. \code{"huang"} (default):
uses each observation's own group fitted value as the meta-stage dependent
variable (Huang et al., 2014). \code{"ordonnell"}: uses the deterministic envelope of group betas
evaluated at all observations (O'Donnell et al., 2008).}

\item{selectionF}{A two-sided formula (e.g. \code{selected ~ z1 + z2}) or a named
list of formulas (one per group) specifying the sample selection equation. Only
used when \code{groupType = "sfaselectioncross"}.}

\item{lcmClasses}{Integer (2--5). Number of latent classes for
\code{groupType = "sfalcmcross"}. Default \code{2}. If \code{group} is
not specified, \code{sfametafrontier} automatically splits the data evenly
into \code{lcmClasses} classes.}

\item{whichStart}{Integer. Strategy for obtaining initial values for LCM
optimization. \code{whichStart = 1} uses initialized values for each class,
whereas \code{whichStart = 2} (default) estimates a pooled base homoscedastic
model to provide uniform starting points.}

\item{initAlg}{Character. Initialization algorithm for LCM. A string specifying
the non-gradient or gradient method. Options include \code{"nm"} for
Nelder-Mead (default), \code{"bhhh"}, \code{"bfgs"}, \code{"cg"}, or
\code{"sann"}.}

\item{initIter}{Integer. Initialization iterations for LCM. Default
\code{100}.}

\item{lType}{Character. Likelihood type for selection model. Options include
\code{"ghermite"} for Gauss-Hermite quadrature (default) or \code{"msl"} for
Maximum Simulated Likelihood.}

\item{Nsub}{Integer. Number of quadrature nodes/subdivisions for the
selection model integration when \code{lType = "ghermite"}. Default
\code{100}.}

\item{uBound}{Numeric. Upper bound for integration in the selection model.
Default \code{Inf}.}

\item{intol}{Numeric. Integration tolerance for the selection model. Default
\code{1e-6}.}

\item{method}{Optimization algorithm for group models. Default \code{'bfgs'}.
Other options include \code{"bhhh"}, \code{"nr"}, \code{"nm"}, \code{"cg"},
and \code{"sann"}.}

\item{hessianType}{Integer (\code{1} or \code{2}). Determines how the
Hessian matrix is computed for standard SFA models. Default \code{1} uses
analytic (when available) or finite-difference numerical Hessians.}

\item{simType}{Character. Simulation type for MSL. Options are \code{'halton'}
(default), \code{'generalized_halton'}, \code{'sobol'}, or \code{'random'}.}

\item{Nsim}{Integer. Number of MSL draws. Default \code{100}.}

\item{prime}{Integer. Prime number for Halton draws. Default \code{2}.}

\item{burn}{Integer. Number of initial Halton draws discarded. Default \code{10}.}

\item{antithetics}{Logical. If \code{TRUE}, evaluates antithetic draws to reduce
variance in MSL. Default \code{FALSE}.}

\item{seed}{Numeric seed. Default \code{12345}.}

\item{itermax}{Maximum iterations. Default \code{2000}.}

\item{printInfo}{Logical. Default \code{FALSE}.}

\item{tol}{Convergence tolerance. Default \code{1e-12}.}

\item{gradtol}{Gradient tolerance. Default \code{1e-06}.}

\item{stepmax}{Step max for \code{ucminf}. Default \code{0.1}.}

\item{qac}{QAC for \code{'bhhh'}/\code{'nr'}. Default \code{'marquardt'}.}

\item{...}{Additional arguments passed to the second-stage SFA call when
\code{metaMethod = "sfa"}.}

\item{x}{An object of class \code{'sfametafrontier'} (for printing).}
}
\value{
\code{\link{sfametafrontier}} returns a list of class \code{'sfametafrontier'} containing the following elements:
\item{groupModels}{A list containing the fitted frontier models for each group (class \code{'sfacross'}, \code{'sfaselectioncross'}, or \code{'sfalcmcross'}).}
\item{metaSfaObj}{The fitted metafrontier model object. If \code{metaMethod = "sfa"}, this is an object of class \code{'sfacross'} representing the second-stage stochastic frontier. If \code{metaMethod = "lp"} or \code{"qp"}, this contains optimization statistics and coefficients from the deterministic envelope.}
\item{metaRes}{A matrix or data frame of the estimated metafrontier coefficients, standard errors, z-values, and p-values.}
\item{efficiencies}{A list containing efficiency estimates, including group-specific technical efficiencies (\code{TE_group}), metafrontier technical efficiencies (\code{TE_meta}), and the metatechnology ratios (\code{MTR}).}
\item{formula}{The formula used for the frontier.}
\item{metaMethod}{The metafrontier estimation method used (\code{"lp"}, \code{"qp"}, or \code{"sfa"}).}
\item{sfaApproach}{The SFA approach used in the second stage (\code{"huang"} or \code{"ordonnell"}).}
\item{groupType}{The type of group-level models estimated (\code{"sfacross"}, \code{"sfaselectioncross"}, or \code{"sfalcmcross"}).}
\item{groups}{A character vector containing the names of the unique groups identified in the data.}
}
\description{
\code{\link{sfametafrontier}} estimates a stochastic metafrontier model
following the theoretical frameworks of Battese, Rao, and O'Donnell (2004) and O'Donnell, Rao, and
Battese (2008). It additionally implements the two-stage stochastic approach of Huang, Huang, and
Liu (2014). Three types of group-level frontier models from the \code{sfaR} package are supported:
standard stochastic frontier analysis (\code{\link[sfaR]{sfacross}}), sample selection SFA
(\code{\link[sfaR]{sfaselectioncross}}), and latent class SFA (\code{\link[sfaR]{sfalcmcross}}).
}
\details{
The stochastic metafrontier analysis workflow comprises two sequential stages.
Suppose we have \eqn{N} observations divided into \eqn{G} technology groups.
The underlying group frontier for firm \eqn{i} in group \eqn{g} at time \eqn{t} is specified as:
\deqn{y_{it} = f(x_{it}, \beta_{(g)}) e^{v_{it} - u_{it}}}
where \eqn{f(\cdot)} is the deterministic frontier (e.g., translog or Cobb-Douglas),
\eqn{x_{it}} represents the input vector (or output vector for cost models),
\eqn{\beta_{(g)}} is the technology parameter vector for group \eqn{g},
\eqn{v_{it}} is the statistical noise, and \eqn{u_{it} \ge 0} represents technical inefficiency.

\enumerate{
\item \strong{Group-specific estimations:} The data is split into \eqn{G} groups
based on the \code{group} variable (unless \code{groupType="sfalcmcross"}
with \code{group} omitted, in which case a single pooled latent class model
is estimated to map observations to underlying groups automatically). For each explicitly or
implicitly defined group, a frontier model is estimated natively by maximizing
the log-likelihood function.
\item \strong{Metafrontier estimation:} The global metafrontier \eqn{f(x_{it}, \beta^*)}
envelopes all group frontiers \eqn{f(x_{it}, \beta_{(g)})}. The methodologies are:
\itemize{
\item \strong{Linear Programming (LP):} Fits a deterministic envelope over the fitted
group frontier values by minimizing the absolute sum of deviations (Battese et al., 2004).
The objective is to find a single parameter vector \eqn{\beta^*} such that the
metafrontier predictions are completely uniformly larger than the group-specific predictions:
\deqn{\min_{\beta^*} \sum_{i} \sum_{t} \left| \ln f(x_{it}, \beta^*) - \ln \hat{f}(x_{it}, \hat{\beta}_{(g)}) \right|}
subject to \eqn{\ln f(x_{it}, \beta^*) \ge \ln \hat{f}(x_{it}, \hat{\beta}_{(g)})}.
\item \strong{Quadratic Programming (QP):} Similar to LP, but minimizes the sum of squared deviations
between the metafrontier and the underlying group frontiers.
\item \strong{Stochastic Metafrontier (Huang et al., 2014):} Formulates the relationship between the
metafrontier and the group frontier stochastically. Because the true group frontiers
are unobservable, Huang et al. replace them with their estimates:
\deqn{\ln \hat{f}(x_{it}, \hat{\beta}_{(g)}) = \ln f(x_{it}, \beta^*) + V_{it} - U_{it}}
where \eqn{V_{it}} absorbs the statistical noise mapping from the first-stage estimation
(representing the estimation error of the group frontier),
and \eqn{U_{it} \ge 0} captures the technology gap between the group frontier and the
global metafrontier. This method relies directly on estimating a second-stage stochastic frontier
using the group-specific fitted values \eqn{\ln \hat{y}_{it}} as the dependent variable.
\item \strong{Stochastic Metafrontier (O'Donnell et al., 2008):} Derives a stochastic metafrontier by fundamentally
fitting an SFA over the pre-computed, deterministically enveloped values across all observations.
Specifically, the dependent variable in this secondary stage relies on the theoretical
values extracted via mathematical programming.
}
\item \strong{Efficiencies and Metatechnology Ratios (MTR):}
\itemize{
\item Group-specific Technical Efficiency (TE_group): \eqn{TE_{it}^g = exp(-u_{it})}.
\item Metafrontier Technical Efficiency (TE_meta): \eqn{TE_{it}^*} = \eqn{exp(-u_{it} - U_{it})}.
\item Metatechnology Ratio (MTR): The ratio mapping the distance from the group frontier
to the potential metafrontier: \eqn{MTR_{it} = \frac{TE_{it}^*}{TE_{it}^g} = exp(-U_{it})}.
}
}

When \code{groupType = "sfaselectioncross"}, only the selected observations
(\code{selectDum == 1}) participate in the metafrontier; the MTR evaluates as
\code{NA} for non-selected observations. When \code{groupType = "sfalcmcross"},
the best-posterior-class fitted value \eqn{y_{it}^{c^*}} is routed to the metafrontier algorithm.
}
\examples{
\dontrun{
## 1. Standard SFA Metafrontier Models
data("ricephil", package = "sfaR")
ricephil$group <- cut(ricephil$AREA,
  breaks = quantile(ricephil$AREA, probs = c(0, 1 / 3, 2 / 3, 1), na.rm = TRUE),
  labels = c("small", "medium", "large"),
  include.lowest = TRUE
)

# Linear Programming (LP) Metafrontier
meta_lp <- sfametafrontier(
  formula = log(PROD) ~ log(AREA) + log(LABOR) + log(NPK),
  data = ricephil, group = "group", S = 1, udist = "hnormal",
  metaMethod = "lp"
)
summary(meta_lp)

# Quadratic Programming (QP) Metafrontier
meta_qp <- sfametafrontier(
  formula = log(PROD) ~ log(AREA) + log(LABOR) + log(NPK),
  data = ricephil, group = "group", S = 1, udist = "hnormal",
  metaMethod = "qp"
)

# Huang (2014) Two-stage SFA Metafrontier
meta_huang <- sfametafrontier(
  formula = log(PROD) ~ log(AREA) + log(LABOR) + log(NPK),
  data = ricephil, group = "group", S = 1, udist = "hnormal",
  metaMethod = "sfa", sfaApproach = "huang"
)

# O'Donnell (2008) Stochastic Metafrontier on LP base
data("utility", package = "sfaR")
meta_ordonnell <- sfametafrontier(
  formula = log(tc / wf) ~ log(y) + I(1 / 2 * (log(y))^2) +
    log(wl / wf) + log(wk / wf) + I(1 / 2 * (log(wl / wf))^2) + I(1 / 2 * (log(wk / wf))^2) +
    I(log(wl / wf) * log(wk / wf)) + I(log(y) * log(wl / wf)) + I(log(y) * log(wk / wf)),
  data = utility, group = "regu", S = -1, udist = "hnormal",
  metaMethod = "sfa", sfaApproach = "ordonnell"
)

## 2. Latent Class Metafrontier (LCM) Models - Unobserved Groups
# LP Metafrontier using 2 posterior classes built automatically
meta_lcm_lp <- sfametafrontier(
  formula = log(tc / wf) ~ log(y) + I(1 / 2 * (log(y))^2) +
    log(wl / wf) + log(wk / wf) + I(1 / 2 * (log(wl / wf))^2) + I(1 / 2 * (log(wk / wf))^2) +
    I(log(wl / wf) * log(wk / wf)) + I(log(y) * log(wl / wf)) + I(log(y) * log(wk / wf)),
  data = utility, S = -1, groupType = "sfalcmcross", lcmClasses = 2,
  metaMethod = "lp"
)
summary(meta_lcm_lp)

# Huang (2014) stochastic metafrontier on LCM classes
meta_lcm_huang <- sfametafrontier(
  formula = log(tc / wf) ~ log(y) + I(1 / 2 * (log(y))^2) +
    log(wl / wf) + log(wk / wf) + I(1 / 2 * (log(wl / wf))^2) + I(1 / 2 * (log(wk / wf))^2) +
    I(log(wl / wf) * log(wk / wf)) + I(log(y) * log(wl / wf)) + I(log(y) * log(wk / wf)),
  data = utility, S = -1, groupType = "sfalcmcross", lcmClasses = 2,
  metaMethod = "sfa", sfaApproach = "huang"
)

## 3. Sample Selection Metafrontier Models
ricephil$laterSurvey <- as.integer(ricephil$YEARDUM > 3)
# LP Metafrontier using generalized sample selection handling bias
meta_sel_lp <- sfametafrontier(
  formula = log(PROD) ~ log(AREA) + log(LABOR) + log(NPK),
  data = ricephil, group = "group", S = 1, groupType = "sfaselectioncross",
  selectionF = laterSurvey ~ EDYRS + AGE, metaMethod = "lp"
)
summary(meta_sel_lp)
}

}
\references{
Battese, G. E., Rao, D. S. P., and O'Donnell, C. J. 2004. A metafrontier
production function for estimation of technical efficiencies and technology
gaps for firms operating under different technologies.
\emph{Journal of Productivity Analysis}, \bold{21}(1), 91--103.
\url{https://doi.org/10.1023/B:PROD.0000012454.06094.29}

Huang, C. J., Huang, T.-H., and Liu, N.-H. 2014. A new approach to
estimating the metafrontier production function based on a stochastic
frontier framework. \emph{Journal of Productivity Analysis},
\bold{42}(3), 241--254.
\url{https://doi.org/10.1007/s11123-014-0402-2}

O'Donnell, C. J., Rao, D. S. P., and Battese, G. E. 2008. Metafrontier
frameworks for the study of firm-level efficiencies and technology ratios.
\emph{Empirical Economics}, \bold{34}(2), 231--255.
\url{https://doi.org/10.1007/s00181-007-0119-4}
}
\seealso{
\code{\link[sfaR]{sfacross}}, \code{\link[sfaR]{sfaselectioncross}},
\code{\link[sfaR]{sfalcmcross}}
}
\keyword{metafrontier}
\keyword{models}
\keyword{optimize}
